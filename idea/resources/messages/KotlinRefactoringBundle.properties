cannot.refactor.not.expression=Cannot find an expression to introduce
cannot.refactor.not.expression.to.extract=Cannot find an expression to extract
introduce.variable=Introduce Variable
introduce.property=Introduce Property
introduce.parameter=Introduce Parameter
cannot.refactor.no.container=Cannot refactor in this place
cannot.refactor.no.expression=Cannot perform refactoring without an expression
cannot.refactor.no.type=Cannot perform refactoring without a type
cannot.refactor.syntax.errors=Cannot refactor due to erroneous code
cannot.refactor.expression.has.unit.type=Cannot introduce expression of unit type
cannot.refactor.package.expression=Cannot introduce package reference
extract.function=Extract Function
cannot.extract.method=Cannot find statements to extract
selected.code.fragment.has.multiple.output.values=Selected code fragment has more than 3 output values:
declarations.are.used.outside.of.selected.code.fragment=Following declarations are used outside of selected code fragment:
selected.code.fragment.has.multiple.exit.points=Selected code fragment has multiple exit points
selected.code.fragment.has.output.values.and.exit.points=Selected code fragment has output values as well as alternative exit points
parameter.types.are.not.denotable=Cannot extract method since following types are not denotable in the target scope:
declarations.will.move.out.of.scope=Following declarations won't be available outside of extracted function body:
cannot.extract.super.call=Cannot extract super-call
cannot.refactor.synthesized.function=Cannot refactor synthesized function ''{0}''
error.types.in.generated.function=Cannot generate function with erroneous return type
cannot.introduce.parameter.of.0.type=Cannot introduce parameter of type ''{0}''

0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} has detected {1} code {1,choice,1#fragment|2#fragments} in {2} that can be replaced with {3}. Would you like to review and replace {1,choice,1#it|2#them}?

error.wrong.caret.position.function.or.constructor.name=The caret should be positioned at the name of the function or constructor to be refactored.
error.cant.refactor.vararg.functions=Can't refactor the function with variable arguments
function.name.is.invalid=Function name is invalid
return.type.is.invalid=Return type is invalid
parameter.name.is.invalid=Parameter name ''{0}'' is invalid
parameter.type.is.invalid=Parameter type ''{0}'' is invalid
column.name.val.var=Val/Var

refactoring.move.non.kotlin.file=Target must be a Kotlin file

0.will.no.longer.be.accessible.after.extraction={0} will no longer be accessible after extraction
0.will.become.invisible.after.extraction={0} will become invisible after extraction
setter.of.0.will.become.invisible.after.extraction = Setter of {0} will become invisible after extraction

naming.convention.will.be.violated.after.rename=Naming conventions will be violated after rename

file.does.not.exist=File {0} does not exist.\nDo you want to create it?
text.caller.text.with.highlighted.callee.call.would.be.shown.here=Caller text\nwith highlighted callee call would be shown here
text.callee.text.would.be.shown.here=Callee text would be shown here
text.anonymous=[Anonymous]
label.text.visibility=&Visibility:\u0020
label.text.type=&Type:\u0020
label.text.name=&Name:\u0020
error.text.invalid.default.receiver.value=Invalid default receiver value
error.text.invalid.receiver.type=Invalid receiver type
error.text.invalid.return.type=Invalid return type
error.text.invalid.name=Invalid name
label.text.receiver.type=Receiver &type:\u0020
checkbox.text.extension.property=E&xtension property:\u0020
label.text.default.receiver.value=&Default receiver value:\u0020
error.text.can.t.change.signature.of.method=Can''t change signature of {0} method
text.default.value=\ // default value = {0}
message.text.return.type.cannot.be.resolved=Return type ''{0}'' cannot be resolved.\nContinue?
text.parameter=parameter ''{0}''
text.receiver=receiver
message.type.for.cannot.be.resolved=Type ''{0}'' for {1} cannot be resolved.\nContinue?
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=Change signature is not applicable to dynamically invoked functions
text.function=function
text.constructor=constructor
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=There is already a variable ''{0}'' in {1}. It will conflict with the new parameter.
text.function.already.exists=Function already exists: ''{0}''
text.there.is.already.a.parameter=There is already a parameter ''{0}'' in {1}. It will conflict with the new parameter.
text.duplicating.local.variable=Duplicating local variable ''{0}''
text.duplicating.property=Duplicating property ''{0}''
text.duplicating.parameter=Duplicating parameter ''{0}''
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=Parameter reference can''t be safely replaced with {0} since {1} is ambiguous in this context
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=Parameter reference can''t be safely replaced with {0} since target function can''t be referenced in this context
text.explicit.receiver.is.already.present.in.call.element.0=Explicit receiver is already present in call element: {0}
text.receiver.can.t.be.safely.transformed.to.value.argument=Receiver can''t be safely transformed to value argument: {0}
text.0.will.no.longer.be.accessible.after.signature.change={0} will no longer be accessible after signature change
column.name.receiver=Receiver: