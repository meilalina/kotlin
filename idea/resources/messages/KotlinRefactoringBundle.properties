0.1.is.never.used={0} ''{1}'' is never used
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} has detected {1} code {1,choice,1#fragment|2#fragments} in {2} that can be replaced with {3}. Would you like to review and replace {1,choice,1#it|2#them}?
0.usages.are.not.supported.by.the.inline.refactoring.they.won.t.be.processed={0} usages are not supported by the Inline refactoring. They won''t be processed.
0.will.become.invisible.after.extraction={0} will become invisible after extraction
0.will.no.longer.be.accessible.after.extraction={0} will no longer be accessible after extraction
action.text.append=Append
action.text.cancel=Cancel
action.text.overwrite=Overwrite
cannot.extract.method=Cannot find statements to extract
cannot.extract.super.call=Cannot extract super-call
cannot.inline.property.with.accessor.s.and.backing.field=Cannot inline property with accessor(s) and backing field
cannot.introduce.parameter.of.0.type=Cannot introduce parameter of type ''{0}''
cannot.refactor.expression.has.unit.type=Cannot introduce expression of unit type
cannot.refactor.no.container=Cannot refactor in this place
cannot.refactor.no.expression=Cannot perform refactoring without an expression
cannot.refactor.no.type=Cannot perform refactoring without a type
cannot.refactor.not.expression.to.extract=Cannot find an expression to extract
cannot.refactor.not.expression=Cannot find an expression to introduce
cannot.refactor.package.expression=Cannot introduce package reference
cannot.refactor.syntax.errors=Cannot refactor due to erroneous code
cannot.refactor.synthesized.function=Cannot refactor synthesized function ''{0}''
checkbox.text.declare.with.var=Declare with &var
checkbox.text.extension.property=E&xtension property:\u0020
checkbox.text.introduce.default.value=Introduce &default value
checkbox.text.replace.all.occurrences.0=&Replace all occurrences ({0})
checkbox.text.specify.type.explicitly=Specify &type explicitly
column.name.receiver=Receiver:
column.name.val.var=Val/Var
declarations.are.used.outside.of.selected.code.fragment=Following declarations are used outside of selected code fragment:
declarations.will.move.out.of.scope=Following declarations won't be available outside of extracted function body:
description.a.reference.to.extracted.type.parameter=a reference to extracted type parameter
error.cant.refactor.vararg.functions=Can't refactor the function with variable arguments
error.hint.text.cannot.inline.0.from.a.decompiled.file=Cannot inline ''{0}'' from a decompiled file
error.text.can.t.change.signature.of.method=Can''t change signature of {0} method
error.text.can.t.copy.class.to.the.containing.file=Can''t copy class to the containing file
error.text.can.t.generate.0.1=Can''t generate {0}: {1}
error.text.can.t.introduce.lambda.parameter.for.this.expression=Can''t introduce lambda parameter for this expression
error.text.can.t.introduce.property.for.this.expression=Can''t introduce property for this expression
error.text.different.name.expected=Different name expected
error.text.expression.has.no.type=Expression has no type
error.text.extraction.from.expect.class.is.not.yet.supported=Extraction from expect class is not yet supported
error.text.extraction.from.non.jvm.class.is.not.yet.supported=Extraction from non-JVM class is not yet supported
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=Inline Function is not supported for functions with multiple return statements.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=Inline Function is not supported for functions with return statements not at the end of the body.
error.text.interface.cannot.be.extracted.from.an.annotation.class=Interface cannot be extracted from an annotation class
error.text.introduce.parameter.is.not.available.for.default.value=Introduce Parameter is not available for default value
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=Introduce Parameter is not available inside of annotation entries
error.text.invalid.default.receiver.value=Invalid default receiver value
error.text.invalid.name=Invalid name
error.text.invalid.parameter.name=Invalid parameter name
error.text.invalid.parameter.type=Invalid parameter type
error.text.invalid.receiver.type=Invalid receiver type
error.text.invalid.return.type=Invalid return type
error.text.no.type.to.refactor=No type to refactor
error.text.refactoring.is.not.applicable.in.the.current.context=Refactoring is not applicable in the current context
error.text.superclass.cannot.be.extracted.from.an.annotation.class=Superclass cannot be extracted from an annotation class
error.text.type.reference.is.expected=Type reference is expected
error.types.in.generated.function=Cannot generate function with erroneous return type
error.wrong.caret.position.function.or.constructor.name=The caret should be positioned at the name of the function or constructor to be refactored.
extract.function=Extract Function
family.name.update.usages.on.declarations.cut.paste=Update usages on declarations cut/paste
file.does.not.exist=File {0} does not exist.\nDo you want to create it?
function.name.is.invalid=Function name is invalid
introduce.parameter=Introduce Parameter
introduce.property=Introduce Property
introduce.type.parameter.to.declaration=Introduce type parameter to declaration
introduce.type.parameter=Introduce Type Parameter
introduce.variable=Introduce Variable
label.text.default.receiver.value=&Default receiver value:\u0020
label.text.introduce.as=&Introduce as:\u0020
label.text.name=&Name:\u0020
label.text.receiver.type=Receiver &type:\u0020
label.text.target.file.name=Target file name:
label.text.type=&Type:\u0020
label.text.visibility=&Visibility:\u0020
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=Change signature is not applicable to dynamically invoked functions
message.do.not.show.for.local.variables.in.future=Do not show for local variables in future
message.text.return.type.cannot.be.resolved=Return type ''{0}'' cannot be resolved.\nContinue?
message.text.type.alias.0.is.never.used=Type alias ''{0}'' is never used
message.type.for.cannot.be.resolved=Type ''{0}'' for {1} cannot be resolved.\nContinue?
name.extract.interface=Extract Interface
name.inline.type.alias=Inline Type Alias
name.introduce.import.alias=Introduce Import Alias
name.introduce.lambda.parameter=Introduce Lambda Parameter
name.introduce.parameter1=Introduce Parameter
name.introduce.type.alias=Introduce Type Alias
name.kdoc.for.abstracts=KDoc for abstracts
naming.convention.will.be.violated.after.rename=Naming conventions will be violated after rename
non.kotlin.usage.0=Non-Kotlin usage: {0}
parameter.name.is.invalid=Parameter name ''{0}'' is invalid
parameter.type.is.invalid=Parameter type ''{0}'' is invalid
parameter.types.are.not.denotable=Cannot extract method since following types are not denotable in the target scope:
refactoring.move.non.kotlin.file=Target must be a Kotlin file
return.type.is.invalid=Return type is invalid
searching.usages.of.0.parameter=Searching usages of ''{0}''parameter
selected.code.fragment.has.multiple.exit.points=Selected code fragment has multiple exit points
selected.code.fragment.has.multiple.output.values=Selected code fragment has more than 3 output values:
selected.code.fragment.has.output.values.and.exit.points=Selected code fragment has output values as well as alternative exit points
setter.of.0.will.become.invisible.after.extraction = Setter of {0} will become invisible after extraction
text.0.is.not.allowed.in.the.target.context=''{0}'' is not allowed in the target context
text.0.to.inline={0} to inline
text.0.will.no.longer.be.accessible.after.signature.change={0} will no longer be accessible after signature change
text.all=All
text.anonymous=[Anonymous]
text.callee.text.would.be.shown.here=Callee text would be shown here
text.caller.text.with.highlighted.callee.call.would.be.shown.here=Caller text\nwith highlighted callee call would be shown here
text.cannot.inline.0.1.usages=Cannot inline {0}/{1} usages
text.class.0.already.exists.in.the.target.scope=Class {0} already exists in the target scope 
text.constructor=constructor
text.create.destructuring.declaration=Create destructuring declaration
text.create.single.variable=Create single variable
text.declaration=declaration
text.default.value=\ // default value = {0}
text.duplicating.local.variable=Duplicating local variable ''{0}''
text.duplicating.parameter=Duplicating parameter ''{0}''
text.duplicating.property=Duplicating property ''{0}''
text.explicit.receiver.is.already.present.in.call.element.0=Explicit receiver is already present in call element: {0}
text.extract.superclass=Extract Superclass
text.file.0.already.exists.in.1=File {0} already exists in {1}
text.function.already.exists=Function already exists: ''{0}''
text.function=function
text.inline.0.1.2=Inline {0} ''{1}''? {2}
text.inline.0=Inline {0}
text.inline.all.references.and.0.the.1=Inline all references and {0} the kind {1}
text.inline.recursive.function.is.supported.only.on.references=Inline recursive function is supported only on references
text.inline.this.reference.and.keep.the.0=Inline this reference and keep the {0}
text.inlining.0.1=Inlining {0} {1} 
text.introduce.default.value=Intro&duce default value
text.keep=keep
text.lambda.parameter=lambda parameter
text.lambda.parameters=Lambda &parameters:\u0020
text.lambda.return.type=Lambda return &type
text.lazy.property=lazy property
text.local.property=property
text.local.variable=local variable
text.name=Name
text.no.name.provided.for.type.alias=No name provided for type alias
text.parameter.0=parameter ''{0}''
text.parameter.name=Parameter &name:\u0020
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=Parameter reference can''t be safely replaced with {0} since {1} is ambiguous in this context
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=Parameter reference can''t be safely replaced with {0} since target function can''t be referenced in this context
text.parameter.type=Parameter &type:\u0020
text.parameter=parameter ''{0}''
text.parameters=&Parameters
text.proceed.with.extraction=Proceed with extraction
text.process.duplicates=Process Duplicates
text.property.with.getter=property with getter
text.property.with.initializer=property with initializer
text.property=property
text.receiver.can.t.be.safely.transformed.to.value.argument=Receiver can''t be safely transformed to value argument: {0}
text.receiver=receiver
text.refactoring.can.t.be.performed.on.the.selected.code.element=Refactoring can''t be performed on the selected code element
text.refactoring.is.not.applicable.to.this.code.fragment=Refactoring is not applicable to this code fragment
text.remove.0.no.longer.used=Remove {0} no longer used
text.remove=remove
text.select.target.code.block.file=Select target code block / file
text.select.target.code.block=Select target code block
text.select.target.file=Select target file
text.the.following=The following
text.there.is.already.a.parameter=There is already a parameter ''{0}'' in {1}. It will conflict with the new parameter.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=There is already a variable ''{0}'' in {1}. It will conflict with the new parameter.
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=Type alias cannot refer to types which aren''t accessible in the scope where it''s defined
text.type.alias.name.must.be.a.valid.identifier.0=Type alias name must be a valid identifier: {0}
text.type.alias=type alias
text.type.already.exists.in.the.target.scope=Type {0} already exists in the target scope
text.type.parameter.names.must.be.distinct=Type parameter names must be distinct
text.type.parameters=Type &Parameters
text.type=Type
text.update.usages.to.reflect.declaration.0.move=Update usages to reflect {0, choice, 0#declaration|1#declarations} move
text.variable=variable
title.inline.function=Inline Function
title.introduce.parameter.to.declaration=Introduce parameter to declaration
title.select.target.code.block=Select target code block
unsupported.usage.0=Unsupported usage: {0}